---
layout: post
title: ???
categories: cxx11
short: where I ???
published: false
---

The new C++ standard provides us with various tools for writing
multithreaded/concurrent/asynchronous code.

### What's wrong with `std::async`

`std::async` is a sadly defficient tool.

The main issue is that, unlike any other `future`s produced by the standard
library, the `future`s returned by `std::async` block on destruction. This leads
to this common example running two tasks sequentially instead of concurrently:

{% highlight cpp %}
void f_and_g() {
    std::async(std::launch::async, f);
    std::async(std::launch::async, g);
}
{% endhighlight %}

I think the fact that `std::async` can so easily result in accidental sequential
execution speaks volumes about how broken this is.

A quick solution involves extending the lifetime of the returned futures, so
that, instead of being temporaries destroyed at the end of their expression (and
thus blocking before the next line is run), they last longer.

{% highlight cpp %}
void f_and_g() {
    auto result_f = std::async(std::launch::async, f);
    auto result_g = std::async(std::launch::async, g);
}
{% endhighlight %}

It does not matter that we don't care about the results: all we want is to delay
destruction of the `future` objects, because that blocks.

However this only delays that until the end of the current scope. If that's not
desirable, one can now try to work around this again by extending the lifetime
further. There are several possible ways of doing that, but they are clunky, and
some only move the problem elsewhere.

blah blah about non=solutions. Leaking resources or launching a thread manually
don't really cut it in my opinion.

For this I recommend against `std::async`. This really needs to get fixed in the
next iteration of the standard, and I think that's the general opinion of the
committee as well.

### Alternatives

For now, I stick to other sources of futures. Only futures from `std::async`
have this broken behaviour in the destructor. No other futures in the standard
library suffer from this illness.

My favourite for this is `packaged_task`. One can build a threadpool with a
concurrent queue of packaged tasks and a set of worker threads in loops taking
work from that queue. `packaged_task` takes care of capturing the result (or
exceptions) from the task and forwarding it to the future that it will return.

The standard lacks building blocks of a high enough level for making building a
threadpool easy (like concurrent queues), but one can find implementations
elsewhere (Boost, Asio, TBB, PPL).

{% highlight cpp %}
class thread_pool {
    thread_pool() : thread_pool(std::thread::hardware_concurrency()) {}
    explicit thread_pool(unsigned threads)
    : service(std::thread::hardware_concurrency()) {
        for(unsigned i = 0; i < threads; ++threads) {
            std::thread([&service]{ service.run(); }).detach();
        }
    }
    ~thread_pool() { service.stop(); }

    void add_this_thread() { service.run(); }

    template <typename Fun, typename Result = ResultOf<Fun()>>
    std::future<Result> run(Fun&& fun) {
        std::packaged_task<Result()> task(std::forward<Fun>(fun));
        auto future = task.get_future();
        service.post(std::move(task));
        return future;
    }

    boost::asio::io_service service;
};
{% endhighlight %}

