---
layout: post
title: The little tail that could
categories: unicode
short: where I expound upon ogonek's design goals
published: false
---

For the past year or so, I have been dedicating some of my free time to the
design and implementation of a C++11 library for dealing with Unicode, that I
decided to dub 'ogonek'.

Now, for some background, I have a very poor opinion of many C++ APIs out there.
Boost is pretty much the only one that I hold in high regard in that
respect&emdash;even though I do have my complaints about it.

For my own API, the first things I set in stone were the design goals and a few
golden rules to produce an API "the way I like it". I feel like some of these
should be the rule everywhere, but as I learned after all this time, they are
not. Still, since I think they are important rules, I am following them in my
interface design, and listing them here for others to get an understanding of
why some things are the way they are.

## The pit of success

I really like the pit of success/pit of despair analogy. Some languages/APIs
make it really easy for you to mess up&emdash;a small mistake and you fall into
the pit of despair. They require a lot of care to do things right. You are
basically walking on the border of the pit of despair, and once you fall in, it
takes effort to get out of it.

Some other languages/APIs make it hard to mess up and instead lead you naturally
to good solutions. This is called "pushing you into the pit of success".  If you
want to do something that is questionable and dangerous with one of these
languages/APIs, you need to work for and climb out of the pit of success.

As should be obvious by now, I have a strong dislike for pit of despair APIs,
and a strong preference for pit of success APIs. Ogonek's API is designed to be
a pit of success API.

Validity and correctnesss come first; speed is irrelevant in the face of those.
But don't get me wrong&emdash;none of this means that I am "designing for slow".
Efficiency is still a valid concern, and I have indeed made several design
decisions that stem from a need for efficiency, but always within the bounds of
correctness.

In the end, I am striving for having my cake and eating it too: I want a design
that favours correctness and is efficient. That may be a lot to ask for, but I
believe I can achieve a design that enforces correctness and is efficient enough
for many tasks.

In few words, whenever the choice between a correct design and an efficient
design must be made, I pick the correct design. Whenever I can pick both, I pick
both.

As you will see from the rest of this article, this pit of success idea is the
overarching theme of most decisions I made in the API and is highly pervasive
throughout it.

## Explicit is better than implicit

If you care about correctness, you don't want all kinds of stuff happening
behind your back as that makes it harder to keep track of what is happening and
makes it easier for mistakes to go unnoticed.

Some people prefer "convenience" APIs that sort of guess what you meant to do
and if they guess wrong you get to debug that later. Oh, the joy. Needless to
say, I don't like those.

Ogonek won't be like that&emdash;it will make no guesses as to what you meant.
Don't expect the library to make any arbitrary decisions in your name&emdash;if
you don't care about some details important for correctness, ogonek is not
suited for you.

I know this might make the API harder to learn, because it will require some
people to be aware of certain things that they never came across before. I think
this is a good thing. It means that if you try to do something without a minimal
understanding of it, the code will likely not compile and you will be forced to
go and grab some fundamental domain knowledge. Once again, it's the pit of
success idea at work.

## Implicit is better than explicit

At this point you may be thinking if this heading is an editorial mistake. It
isn't. While I argued for making some operations explicit, I don't have a fetish
for unnecessarily verbose code. There are many operations that can be performed
implicitly because they aren't lossy, surprising, dangerous, or excessively
inefficient.

These operations that can be implicit are especially common if you follow the
pit of success rule in designing the API as there will be less ways of truly
messing up. And with this the API ends pushing you even harder into the pit of
success, since it gives you less surface area to make mistakes.

In those operations there is usually no choice to be made by the user, and
forcing them to explicitly choose the single alternative available is annoying
and only adds clutter to the code.

In short, operations on ogonek are automated whenever that does not reduce
flexibility or functionality, and require explicit intervention otherwise.

## Fail fast, fail loudly

So what happens whenever the user makes a mistake? Well, something will fail,
sometime. There are several possible times for that failure to manifest itself.
For what concerns API design, the relevant possibilities are, in chronological
order, as follows.

1. Compilation time&emdash;some mistakes can be detected by the compiler.
The most common of such mistakes are either syntactic errors or type errors.
Syntactic errors don't have much influence in API design, but type errors are
very important. The more information that is encoded in types, the more things
can be checked automatically by the compiler.

2. Linkage time&emdash;these are either boring or really annoying to fix. There
used to be a common idiom in C++03&emdash;private copy constructors without a
definition&emdash;that would cause some rare mistakes to manifest themselves at
linkage time, but I don't think there is anything useful about this kind of
errors for driving modern API design or implementation.

3. Testing time&emdash;this is when violated assertions manifest themselves.
Some assertions will always be hit when wrong code is used, and as usual produce
a nasty error message in some test log. Those are very useful to have, because
they point out bad code as soon as it runs, every time it runs. While not
explicitly part of the language-level interface, those assertions do form part
of the effective interface of the library, and they serve to enforce it beyond
what is possible to enforce through type-checking.

4. Run time&emdash;the difference between this and testing time is subtle. Some
mistakes won't manifest at any previous stage, and will manifest under very
unique or unusual circumstances. Unless you are lucky, these can slip through
testing and end up in the final product, undetected until some user finds it and
hopefully files a bug report.

The longer an error is allowed to remain, the more code will be built around it,
and that increases the likelihood of a fix affecting a large portion of other
code.

In ogonek I strive to have as many errors as possible manifest themselves upon
compilation. This means encoding more and more information in types. This
certainly involves some template meta-programming, but so far always in healthy
doses.

A very important property that is encoded in some ogonek types is whether they
represent a well-formed sequence. All externally provided sequences are
considered of unknown well-formedness. Some processes, like validating or
decoding, accept such sequences and return sequences that are thus statically
known well-formed. Some functions accept only well-formed sequences as input,
and using them will sequences of types that have not been blessed by the
well-formedness gods will cause a compiler error&emdash;hopefully I can make it
a descriptive one&emdash;and force you to think about whether your input is
known to be valid or not.

As a side effect of this, I can do some efficiency improvements. Some operations
accept sequences regardless of their well-formedness, like initialising an
instance of ogonek's core string type. Having information about well-formedness
available statically, I can make a validation function that is a no-op when the
input is known well-formed, and performs regular validation otherwise. I really
like this because I get both correctness and efficiency from this design.

## You are not alone

## Escape hatches


